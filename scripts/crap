
export type EndSectionDefinition = {
    name: string;
    inclusive?: boolean;
    matchEnd: (parsedLogLine: string) => boolean;
};
export type SectionDefinition = {
    (parsedLogLine: string): EndSectionDefinition | null;
};

function extractDeep<T extends string>(keys: T[], record: Record<T, any>) {
    let pointer = record;
    [...keys].reverse().forEach(key => {
        if (!record[key]) {
            console.error(record, pointer, keys, key);
            throw new Error(
                'parsing error, cannot find key to insert into record',
            );
        }
        pointer = record[key].subtree;
    });
    return pointer;
}

function analyze(
    lines: string[],
    matchDefinitions: SectionDefinition[],
): Record<string, any> {
    let constructed = {};
    let matchStack: (EndSectionDefinition & { content: string[] })[] = [];
    lines.forEach(line => {
        // resolve ends
        const matchEndIndex = matchStack
            .map(({ matchEnd }) => matchEnd)
            .map(matcher => matcher(line))
            .findIndex(Boolean);

        const cutPoint = matchEndIndex >= 0 ? matchEndIndex : matchStack.length;
        matchStack = matchStack.slice(cutPoint);
        const matchesEnding = matchStack.slice(0, cutPoint);

        matchesEnding.forEach(endingMatch => {
            extractDeep()
        });

        // add content
        matchStack[0].content += `\n${line}`;

        //resolve starts
        const start = matchDefinitions.map(matcher => matcher(line))[0];
        if (start) {
            matchStack = [{ ...start, content: [] }, ...matchStack];
            constructed = {
                ...constructed,
                [start.name]: {
                    subtree: {},
                    name: start.name,
                },
            };
        }
    }, {});
}